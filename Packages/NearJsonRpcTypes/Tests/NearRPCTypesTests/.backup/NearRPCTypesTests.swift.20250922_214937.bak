import XCTest
import NearRPCTypes
import OpenAPIRuntime
import HTTPTypes

actor HTTPTransport: ClientTransport {
    func send(_ request: HTTPRequest, body: OpenAPIRuntime.HTTPBody?, baseURL: URL, operationID: String) async throws -> (HTTPResponse, OpenAPIRuntime.HTTPBody?) {
        var urlRequest = URLRequest(url: baseURL.appendingPathComponent(request.path ?? ""))
        urlRequest.httpMethod = request.method.rawValue
        for header in request.headerFields {
            urlRequest.setValue(header.value, forHTTPHeaderField: header.name.rawName)
        }
        if let body {
            urlRequest.httpBody = try Data(collecting: body, upTo: .max)
        }
        let (data, response) = try await URLSession.shared.data(for: urlRequest)
        let httpResponse = HTTPResponse(response)
        return (httpResponse, data.isEmpty ? nil : .init(data))
    }
}

// [nearskip] final class NearRPCClientTests: XCTestCase {
    func testFetchStatusFromTestnet() async throws {
        print("ðŸ§ª Iniciando prueba de integraciÃ³n final...")

        let client = Client(
            transport: HTTPTransport()
        )

        print("ðŸ“¡ Llamando al mÃ©todo 'status' en la testnet...")

        let response = try await client.status(body: .json(.init(jsonrpc: "2.0", id: "dontcare", method: "status", params: .json(["finality", "final"]))))

        switch response {
        case .ok(let okResponse):
            switch okResponse.body {
            case .json(let statusResult):
                print("âœ… Â¡Respuesta recibida!")
                print("   - Chain ID: \(statusResult.result.chainId)")
                print("   - Ãšltimo bloque: #\(statusResult.result.syncInfo.latestBlockHeight)")
                XCTAssertEqual(statusResult.result.chainId, "testnet")
            }
        case .badRequest, .internalServerError, .undocumented:
            XCTFail("La peticiÃ³n fallÃ³. Respuesta: \(response)")
        }
    }
}